<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一章 绪论 1. 基本概念  数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据项：是具有独立含义的最小标识单元，也称字段、域、属性等 数据元素：数据的基本单位，也称结点、元素、顶点、记录，一个数据元素可由若干个数据项组成 数据对象：性质相同的数据元素的集合 数据结构：指数据之间的相互关系，即组织形式。 逻辑结构：一般程序中出现的形式">
<meta property="og:type" content="article">
<meta property="og:title" content="严蔚敏《数据结构》复习概要">
<meta property="og:url" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/index.html">
<meta property="og:site_name" content="Frostime">
<meta property="og:description" content="第一章 绪论 1. 基本概念  数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据项：是具有独立含义的最小标识单元，也称字段、域、属性等 数据元素：数据的基本单位，也称结点、元素、顶点、记录，一个数据元素可由若干个数据项组成 数据对象：性质相同的数据元素的集合 数据结构：指数据之间的相互关系，即组织形式。 逻辑结构：一般程序中出现的形式">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LL.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RR.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LR_1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LR_2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RL_1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RL_2.png">
<meta property="og:updated_time" content="2019-07-01T07:51:38.236Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="严蔚敏《数据结构》复习概要">
<meta name="twitter:description" content="第一章 绪论 1. 基本概念  数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据项：是具有独立含义的最小标识单元，也称字段、域、属性等 数据元素：数据的基本单位，也称结点、元素、顶点、记录，一个数据元素可由若干个数据项组成 数据对象：性质相同的数据元素的集合 数据结构：指数据之间的相互关系，即组织形式。 逻辑结构：一般程序中出现的形式">
<meta name="twitter:image" content="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LL.png">






  <link rel="canonical" href="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>严蔚敏《数据结构》复习概要 | Frostime</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Frostime</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/严蔚敏《数据结构》复习概要/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zuo Yiping">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frostime">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">严蔚敏《数据结构》复习概要

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-01 11:45:36 / 修改时间：15:51:38" itemprop="dateCreated datePublished" datetime="2019-07-01T11:45:36+08:00">2019-07-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/图/" itemprop="url" rel="index"><span itemprop="name">图</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章-绪论">第一章 绪论</h1>
<h2 id="基本概念">1. 基本概念</h2>
<ul>
<li>数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等</li>
<li>数据项：是具有独立含义的<strong>最小标识单元</strong>，也称<strong>字段</strong>、域、属性等</li>
<li>数据元素：数据的<strong>基本单位</strong>，也称结点、元素、顶点、记录，<strong>一个数据元素可由若干个数据项组成</strong></li>
<li>数据对象：性质相同的数据元素的集合</li>
<li>数据结构：指<strong>数据之间的相互关系</strong>，即组织形式。</li>
<li>逻辑结构：一般程序中出现的形式
<ul>
<li>线性：如一维数组、栈、队列、链表、串等</li>
<li>非线性：如多维数组、广义表、树、图等</li>
</ul></li>
<li>物理结构：内存中的连续存储形式</li>
</ul>
<h2 id="算法五个特征">2. 算法五个特征</h2>
<ul>
<li>输入</li>
<li>输出</li>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
</ul>
<h1 id="第二章-线性表">第二章 线性表</h1>
<h2 id="头指针头结点首元结点第一个元素结点">1. 头指针，头结点，首元结点（第一个元素结点）</h2>
<p>头指针是指向链表中第一个结点的指针。</p>
<p>首元结点是指链表中存储第一个数据元素的结点。</p>
<p>头结点是在首元结点之前附设的一个结点，该结点不存储数据元素，其指针域指向首元结点，其作用主要是为了方便对链表的操作。它可以对空表、非空表以及首元结点的操作进行统一处理。</p>
<h2 id="静态链表">2. 静态链表</h2>
<p>使用数组模拟链表</p>
<p>需要额外维护一个空闲链表</p>
<h2 id="习题">3. 习题</h2>
<h3 id="填空">填空</h3>
<ol type="1">
<li>在顺序表中插入或删除一个元素，需要平均移动 <strong><span class="math inline">\(\frac{n}{2}\)</span> 和 <span class="math inline">\(\frac{n-1}{2}\)</span></strong> 个元素，具体移动的元素个数与<strong>插入或删除元素的位置</strong>有关。</li>
<li>顺序表中逻辑上相邻的元素的物理位置<strong>一定</strong>紧邻。单链表中逻辑上相邻的元素的物理位置<strong>不一定</strong>紧邻。</li>
<li>在单链表中，除了首元结点外，任一结点的存储位置由<strong>前驱结点的后继指针</strong>指示。</li>
<li>在单链表中设置头结点的作用是<strong>方便对空表统一处理</strong></li>
</ol>
<h3 id="在什么情况下用顺序表比链表好">在什么情况下用顺序表比链表好？</h3>
<p>当所涉及的问题常常进行查找等操作，而插入、删除相对较少时，适合采用顺序表。</p>
<h3 id="判断顺序表可以存储非线性结构">判断：顺序表可以存储非线性结构？</h3>
<p>对，比如二叉树的数组表示法。</p>
<h3 id="静态链表中指针表示的是">静态链表中指针表示的是</h3>
<p>数组下标</p>
<h1 id="第三章-栈和队列">第三章 栈和队列</h1>
<h2 id="栈的-base-和-top">1. 栈的 base 和 top</h2>
<ul>
<li>未建立栈时：<code>base == nulltpr</code></li>
<li>空栈：<code>top == base</code></li>
<li>有数据时：<code>top</code> 指向栈顶元素的下一位</li>
</ul>
<h2 id="出入栈的序列">2. 出入栈的序列</h2>
<blockquote>
<p>如果存在入栈序列 i, j, k，则不可能存在出栈序列 k, i, j</p>
</blockquote>
<h2 id="中缀式转后缀式算法">3. 中缀式转后缀式算法</h2>
<ul>
<li>操作符优先级 <code>(</code> &lt; <code>-</code> = <code>+</code> &lt; <code>*</code> = <code>/</code> &lt; <code>^</code></li>
<li>顺序扫描串，遇到字符就把它放入后缀串或者栈中</li>
<li>栈顶元素优先级必须<strong>严格大于</strong>栈底元素优先级</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convertToPostOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = expIn.begin(); it != expIn.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*it))</span><br><span class="line">        &#123;</span><br><span class="line">            expPost += *it;</span><br><span class="line">            <span class="keyword">if</span> (it + <span class="number">1</span> == expIn.end() || !<span class="built_in">isdigit</span>(*(it + <span class="number">1</span>)))</span><br><span class="line">                expPost += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isoperator(*it))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两个括号 ( )</span></span><br><span class="line">            <span class="comment">//( 号直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (*it == <span class="string">'('</span>)</span><br><span class="line">                s.push(*it);</span><br><span class="line">            <span class="comment">//) 号把栈中直到 ( 为止所有符号出栈，加入后缀式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*it == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() != <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    expPost += s.top();</span><br><span class="line">                    expPost += <span class="string">" "</span>;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//普通操作符</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//保证栈顶的符号优先级小于该操作符然后再入栈</span></span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; cmp(s.top(), *it) &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    expPost += s.top();</span><br><span class="line">                    expPost += <span class="string">" "</span>;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈中剩余操作符加入进来</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        expPost += s.top();</span><br><span class="line">        expPost += <span class="string">" "</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> expPost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环队列队列的顺序表示法">循环队列(队列的顺序表示法)</h3>
<ul>
<li>front 和 rear，<strong>rear 指向队尾元素的下一个单元</strong></li>
<li>Enqueue: ++rear</li>
<li>Dequeue: ++front</li>
<li>少用一个单元，<strong>若 front 在 rear 的下一个单元，就表示队列满了</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front == rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Full</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity == front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第四章-串">第四章 串</h1>
<h2 id="空串和空格串的区别">1. 空串和空格串的区别</h2>
<p>一个是长度为 0 的串，一个是全是空格字符的串</p>
<h2 id="串操作最小子集一共-5-种">2. 串操作最小子集（一共 5 种）</h2>
<ul>
<li>StrAssign</li>
<li>StrCompare</li>
<li>StrLength</li>
<li>Concat</li>
<li>SubString</li>
</ul>
<h2 id="串的三种表示方式">3. 串的三种表示方式</h2>
<ul>
<li>定长顺序存储表示</li>
<li>堆分配存储表示</li>
<li>块链存储表示</li>
</ul>
<h1 id="第五章-数组和多维表">第五章 数组和多维表</h1>
<h2 id="多维表的地址计算">1. 多维表的地址计算</h2>
<p>对于n维数组：</p>
<p><span class="math display">\[
A_{m_{1}m_{2}\cdots m_{n}}
\]</span> 假设主序顺序为从左到右。则: <span class="math display">\[
Loc(j_{1}, j_{2},\cdots, j_{n}) = Loc(0, 0, \cdots, 0)+\Big[\sum_{i = 1}^{n-1}\big(j_{i}\prod_{k=i+1}^{n}m_{k}\big)+j_{n}\Big]\times L
\]</span></p>
<p>其中 <span class="math inline">\(L\)</span> 代表每个单元的存储空间。</p>
<p>例：已知 <code>int a[9][3][5][8]</code>，求 <code>a[3][1][2][5]</code> 的地址:</p>
<p><span class="math display">\[
Loc(3, 1, 2, 5) = 0+(3\times(3\times5\times8)+1\times(5\times8)+2\times8+5)\times4
\]</span></p>
<h1 id="第六章-树与二叉树">第六章 树与二叉树</h1>
<h2 id="树的性质">1. 树的性质</h2>
<ul>
<li>结点数 = 出度 + 1 = 边数 + 1</li>
<li>一个 d 次树在第 i 层的结点数 <span class="math inline">\(\leqslant d^{i - 1}\ (i \geqslant 1)\)</span></li>
<li>高度为 h 的 d 次树结点最多为 <span class="math inline">\(\frac{d^h - 1}{d - 1}\)</span></li>
<li>树的度是指各个节点度的最大值</li>
</ul>
<h2 id="二叉树基本概念和性质">2. 二叉树基本概念和性质</h2>
<ul>
<li>二叉树是有序树</li>
<li>第 i 层至多有 <span class="math inline">\(2^{i - 1}\)</span> 个结点</li>
<li>深度为 k，<span class="math inline">\(n \leqslant 2^k - 1\)</span></li>
<li>n 个结点，深度至少为 <span class="math inline">\(\lfloor \log_2{n} \rfloor + 1\)</span></li>
<li><span class="math inline">\(n = n_0 + n_1 + n_2 = n_1 + 2n_2 + 1\)</span>（n = 出度 + 1）</li>
<li><span class="math inline">\(n_0 = n_2 + 1\)</span></li>
<li><span class="math inline">\(n_0 = \lfloor \frac{n}{2} \rfloor\)</span></li>
</ul>
<p>另外有:</p>
<ul>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
<h2 id="二叉树的存储">3. 二叉树的存储</h2>
<ul>
<li><p>顺序存储结构</p>
<p>适用于完全二叉树</p></li>
<li><p>链式存储结构</p>
<ul>
<li><p>二叉链表：left, right</p>
<p>有 <span class="math inline">\(n + 1\)</span> 个空指针域</p></li>
<li><p>三叉链表: left, right, parent</p>
<p>有 <span class="math inline">\(n + 2\)</span> 个空指针域</p></li>
</ul></li>
</ul>
<h2 id="线索二叉树">4. 线索二叉树</h2>
<ul>
<li>使用空指针域（一共 n + 1 个）</li>
<li>左空指针指向前驱，右空指针指向后继</li>
<li>每个结点中增加 LTag 和 RTag 字段用于指明指针到底指向孩子还是前驱后继</li>
<li>根据中序、先序和后序可以构造出三种不同的线索</li>
<li>先序和后序的线索二叉树遍历时仍然需要父母结点的信息，所以只有中序的线索二叉树常用</li>
</ul>
<h2 id="树的存储">5. 树的存储</h2>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h2 id="森林与二叉树转换">6. 森林与二叉树转换</h2>
<ul>
<li>二叉树的左孩子代表原来的树中第一个孩子</li>
<li>二叉树的右孩子代表原来的树中的兄弟结点</li>
</ul>
<h2 id="树的遍历">7. 树的遍历</h2>
<ul>
<li>先根遍历：结果等于树转换成二叉树后进行先序遍历</li>
<li>后根遍历：结果等于树转换出二叉树后进行中序遍历</li>
<li>树没有中序遍历，因为子树无先后之分</li>
</ul>
<h1 id="第七章-图">第七章 图</h1>
<h2 id="图的概念">1. 图的概念</h2>
<p>图分为：</p>
<ul>
<li>无向图</li>
<li>有向图：<code>&lt;v, w&gt;</code>, <code>v-&gt;w</code>，v 称为弧尾，w称为弧头</li>
</ul>
<p>完全图：任意两个点之间都相连</p>
<ul>
<li>无向完全图：<span class="math inline">\(|E| = \frac{n(n-1)}{2}\)</span></li>
<li>有向完全图：<span class="math inline">\(|E| = n(n-1)\)</span></li>
</ul>
<p>带权图：又称网</p>
<p>度：</p>
<ul>
<li>度 <span class="math inline">\(TD(v_i)\)</span> = 出度 + 入度 (<span class="math inline">\(TD(v_i) = OD(v_i) + ID(v_i))\)</span></li>
<li><span class="math inline">\(|E| = \frac{1}{2}\sum{TD(v_i)}\)</span></li>
</ul>
<p>路径：</p>
<ul>
<li>路径、路径的长度、回路</li>
<li>简单路径：序列中不出现重复的点的路径</li>
</ul>
<p>连通性：</p>
<ul>
<li>无向图
<ul>
<li>连通图、连通分量（即极大连通子图）</li>
</ul></li>
<li>有向图
<ul>
<li>强连通图：任意两个<span class="math inline">\(v_i\)</span>和<span class="math inline">\(v_j\)</span>，<span class="math inline">\(v_i \rightarrow v_j\)</span>和<span class="math inline">\(v_j \rightarrow v_i\)</span>均存在</li>
<li>有 <span class="math inline">\(n\)</span> 个点的强连通图至少有 <span class="math inline">\(n\)</span> 个弧</li>
<li>强连通分量</li>
</ul></li>
</ul>
<p>生成树：</p>
<ul>
<li>是一个极小连通子图</li>
<li><span class="math inline">\(n\)</span> 个点，<span class="math inline">\(n - 1\)</span> 条边</li>
</ul>
<h2 id="图的存储">2. 图的存储</h2>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>十字链表</li>
</ul>
<h2 id="生成树">3. 生成树</h2>
<p>生成树是一个极小的连通子图，具有图中所有的 n 个顶点，但只有 n - 1 条边。</p>
<ul>
<li>深度优先生成树</li>
<li>广度优先生成树</li>
</ul>
<p>对于带权无向图(网)而言，希望找权值之和最小的生成树，即最小生成树</p>
<ul>
<li>Prim 算法
<ul>
<li>反复找到一条连接生成树和其补集的最小分支，把它加入生成树中</li>
<li><span class="math inline">\(O(n^2)\)</span>，复杂度只和点有关，和边无关</li>
<li>适合边稠密的图</li>
</ul></li>
<li>Kruskal 算法
<ul>
<li>按权值从小到大依次选取分支，并且要求保证不构成回路</li>
<li><span class="math inline">\(O(e\log{e})\)</span>，复杂度只和边有关，和点无关</li>
<li>适合边稀疏的图</li>
</ul></li>
</ul>
<h2 id="dag-图aov-网拓扑排序">4. DAG 图、AOV 网、拓扑排序</h2>
<ul>
<li><p>DAG：有向无环图</p></li>
<li><p>AOV网：用<strong>定点表示活动</strong>，用<strong>弧表示活动之间的优先关系</strong>的有向图</p>
<p>注意，AOV网中不应该出现有向环，判断是否有有向环可以用拓扑排序的方法</p></li>
<li><p>拓扑排序：根据偏序关系得到一个全序关系的过程</p></li>
</ul>
<p>算法思路：每次从图中找到一个入度为 0 的点，输出；然后把该点和相关的弧从图中删除(相邻的点入度减一)；反复循环</p>
<p>算法流程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = Stack()</span><br><span class="line">把图中所有入度为 <span class="number">0</span> 的点入栈</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> s.empty():</span><br><span class="line">    v = s.pop()</span><br><span class="line">    输出 v</span><br><span class="line">    <span class="comment"># 把 v 和 v 连接的弧从图中删除</span></span><br><span class="line">    <span class="keyword">for</span> vx 邻接于 v:</span><br><span class="line">        vx 入度减一</span><br><span class="line">        <span class="keyword">if</span> vx 入度为 <span class="number">0</span>:</span><br><span class="line">            s.push(vx)</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 <span class="math inline">\(O(n + e)\)</span></p>
<h2 id="aoe-网关键路径">5. AOE 网、关键路径</h2>
<h2 id="最短路径">6. 最短路径</h2>
<h3 id="dijkstra">Dijkstra</h3>
<p>复杂度: <span class="math inline">\(O(n^2)\)</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 额外说明: 用正无穷来表示两个点之间不直接相连，不要使用 0 或其他数字</span></span><br><span class="line">Target: 求 V0 到 &#123;V1, ..., Vn<span class="number">-1</span>&#125; 的最小距离</span><br><span class="line">Input:</span><br><span class="line">    <span class="comment"># 邻接矩阵 [0, n), adjMat[i][j] = +∞ 表示不可达</span></span><br><span class="line">    adjMat</span><br><span class="line">Data Structure:</span><br><span class="line">    S: 最短路径集合</span><br><span class="line">    D[i]: V0 -&gt; Vi 的最小距离</span><br><span class="line">    path[i]: V0 -&gt; Vi 的最短路径中，i 的上一个结点</span><br><span class="line"></span><br><span class="line">Dijkstra:</span><br><span class="line">    <span class="comment"># 初始情况下，D 中存储了可以直达 0 的点</span></span><br><span class="line">    fill(D[i], adjMat[<span class="number">0</span>][i])</span><br><span class="line">    fill(path, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 初始情况下，最短路径集合里只有初始点 V0</span></span><br><span class="line">    S = &#123;V0&#125;</span><br><span class="line">    <span class="comment"># 一共 n 个点，所以需要 n - 1 次循环，每次循环都找到一个最近的点</span></span><br><span class="line">    <span class="keyword">for</span> i = [<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 找到不在最短路径集合S中距离 V0 最近的点</span></span><br><span class="line">        nearestNode = argmax(D[i]), s.t. i <span class="keyword">not</span> <span class="keyword">in</span> S</span><br><span class="line">        <span class="comment"># 把这个点加入最短路径集合</span></span><br><span class="line">        S = S U &#123;nearestNode&#125;</span><br><span class="line">        <span class="comment"># 使用 nearestNode 来更新最短路径</span></span><br><span class="line">        <span class="comment"># 看看有没有可以经过 minNode 使得路径更短的点</span></span><br><span class="line">        startToN = D[nearestNode]</span><br><span class="line">        <span class="keyword">for</span> v, nToV <span class="keyword">in</span> Adj(nearestNode):</span><br><span class="line">            startToV = D[v]</span><br><span class="line">            <span class="comment"># 如果我们发现 V0 -&gt; nNode -&gt; V 的距离小于 V0 -&gt; V，就更新最短路径</span></span><br><span class="line">            <span class="keyword">if</span> startToN + nToV &lt; startToV:</span><br><span class="line">                D[v] = startToN + nToV</span><br><span class="line">                path[v] = nearestNode</span><br></pre></td></tr></table></figure>
<p>路径打印：将 <code>pathLastNode[start:end]</code> 逆序打印即可</p>
<h3 id="floyd">Floyd</h3>
<p>思路：</p>
<blockquote>
<p>假设一共有 n 个点，则邻接矩阵中有 <span class="math inline">\(n^2\)</span> 中路径。我们迭代地考察这 n 个点，看是否能通过把当前的被考察点作为中间节点插入到路径中，使得路径变得更短</p>
</blockquote>
<p>复杂度: <span class="math inline">\(O(n^3)\)</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 额外说明: 用正无穷来表示两个点之间不直接相连，不要使用 0 或其他数字</span></span><br><span class="line">Target: 找到任意两个点之间的最短路径</span><br><span class="line">Input:</span><br><span class="line">    adjMat: 邻接矩阵 [<span class="number">0</span>, n), adjMat[i][j] = +∞ 表示不可达</span><br><span class="line">Data Structure:</span><br><span class="line">    Dis[i][j]: i -&gt; j 最短路径</span><br><span class="line">    path[i][j]: Vi -&gt; Vj 的最短路径上，Vi 的下一个点</span><br><span class="line"></span><br><span class="line">Floyd:</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    Dis = adjMat</span><br><span class="line">    fill(path[i][j], j)</span><br><span class="line">    <span class="comment"># 依次考察 n 个点作为中间结点</span></span><br><span class="line">    <span class="keyword">for</span> mid = [<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">for</span> beg = [<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">for</span> end = [<span class="number">0</span>, n):</span><br><span class="line">                <span class="comment"># 如果更短，就更新</span></span><br><span class="line">                <span class="comment"># 注意这里已经包含了不可达的情况，因为不可达时距离为正无穷</span></span><br><span class="line">                <span class="keyword">if</span> Dis[beg][end] &lt; Dis[beg][mid] + Dis[mid][end]:</span><br><span class="line">                    Dis[beg][end] = Dis[beg][mid] + Dis[mid][end]</span><br><span class="line">                    <span class="comment"># i -&gt; j 首先要经过 i -&gt; k</span></span><br><span class="line">                    path[i][j] = path[i][k]</span><br></pre></td></tr></table></figure>
<p>打印路径: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = i</span><br><span class="line">while x != j:</span><br><span class="line">    print(x)</span><br><span class="line">    x = path[x][j]</span><br></pre></td></tr></table></figure></p>
<h1 id="第九章-查找">第九章 查找</h1>
<h2 id="基本概念-1">1. 基本概念</h2>
<p>几个基本操作</p>
<ol type="1">
<li>查找某特定数据元素是否在查找表中</li>
<li>检索某特定数据元素的各种属性</li>
<li>插入</li>
<li>删除</li>
</ol>
<ul>
<li>静态查找表：只有操作 1 和 2</li>
<li>动态查找表：操作 1~4 都有</li>
</ul>
<p>平均查找长度 ASL：</p>
<ul>
<li><span class="math inline">\(P_i\)</span>：记录 i 出现的概率</li>
<li><span class="math inline">\(C_i\)</span>：查找记录 i 需要的比较次数</li>
</ul>
<p><span class="math display">\[
ASL = \sum_{i = 1}^{n}{P_iC_i}
\]</span></p>
<h2 id="静态查找结构">2. 静态查找结构</h2>
<h3 id="顺序表查找">顺序表查找</h3>
<p><span class="math display">\[
ASL = 
\begin{cases}
    \frac{n+1}{2} &amp;\text{只考虑查找成功的情况}\\
    \frac{3(n+1)}{4} &amp; \text{考虑查找失败的情况}\\
\end{cases}
\]</span></p>
<h3 id="折半查找">折半查找</h3>
<p><span class="math display">\[
ASL = \frac{n+1}{n}\log_2{(n+1)} - 1
\]</span></p>
<p>如果给出了具体的有序表，就得自己画图分析。</p>
<h3 id="分块查找索引顺序表">分块查找(索引顺序表)</h3>
<p>表的数据<strong>分块有序</strong>（就像快排时候的那样）。</p>
<h2 id="动态查找">3. 动态查找</h2>
<h3 id="bst-二叉搜索树">BST 二叉搜索树</h3>
<h3 id="avl-平衡二叉树">AVL 平衡二叉树</h3>
<p>改进版本的 BST 树。要求<strong>任意结点的左右子树高度之差不超过 1</strong>。</p>
<p>对每个结点加入一个平衡因子量，用于记录左右子树高度之差。</p>
<p>关于插入时破坏了平衡的处理办法。分为两类四种：</p>
<ol type="1">
<li>单旋(直接向内侧旋转)</li>
</ol>
<ul>
<li>LL</li>
</ul>
<p><img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LL.png"></p>
<ul>
<li>RR</li>
</ul>
<p><img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RR.png"></p>
<ol start="2" type="1">
<li>双旋(向外后内)</li>
</ol>
<ul>
<li>LR</li>
</ul>
<p><img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LR_1.png"> <img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_LR_2.png"></p>
<ul>
<li>RL</li>
</ul>
<p><img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RL_1.png"> <img src="/2019/07/01/严蔚敏《数据结构》复习概要/AVL_RL_2.png"></p>
<h3 id="b-树">B-树</h3>
<h2 id="哈希表">4. 哈希表</h2>
<h3 id="哈希函数构造方法">哈希函数构造方法</h3>
<ol type="1">
<li>直接定址法</li>
</ol>
<p><span class="math display">\[
H(key) = a * key + b
\]</span></p>
<ol start="2" type="1">
<li>除留余数法</li>
</ol>
<p><span class="math display">\[
H(key) = key \bmod p,\ key \leqslant m
\]</span></p>
<p>p 一般是一个质数。</p>
<h3 id="处理冲突">处理冲突</h3>
<ol type="1">
<li>开放定址法</li>
</ol>
<p><span class="math display">\[
H_i = (H(key) + d_i) \bmod m
\]</span></p>
<p><span class="math inline">\(d_i\)</span> 是一个增量序列。</p>
<ol start="2" type="1">
<li>链地址法</li>
</ol>
<h1 id="第十章-排序">第十章 排序</h1>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/30/十字链表的画法/" rel="next" title="十字链表的画法">
                <i class="fa fa-chevron-left"></i> 十字链表的画法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zuo Yiping</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-绪论"><span class="nav-text">第一章 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法五个特征"><span class="nav-text">2. 算法五个特征</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-线性表"><span class="nav-text">第二章 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#头指针头结点首元结点第一个元素结点"><span class="nav-text">1. 头指针，头结点，首元结点（第一个元素结点）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态链表"><span class="nav-text">2. 静态链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#习题"><span class="nav-text">3. 习题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#填空"><span class="nav-text">填空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在什么情况下用顺序表比链表好"><span class="nav-text">在什么情况下用顺序表比链表好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断顺序表可以存储非线性结构"><span class="nav-text">判断：顺序表可以存储非线性结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态链表中指针表示的是"><span class="nav-text">静态链表中指针表示的是</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-栈和队列"><span class="nav-text">第三章 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的-base-和-top"><span class="nav-text">1. 栈的 base 和 top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出入栈的序列"><span class="nav-text">2. 出入栈的序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中缀式转后缀式算法"><span class="nav-text">3. 中缀式转后缀式算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#循环队列队列的顺序表示法"><span class="nav-text">循环队列(队列的顺序表示法)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-串"><span class="nav-text">第四章 串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空串和空格串的区别"><span class="nav-text">1. 空串和空格串的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串操作最小子集一共-5-种"><span class="nav-text">2. 串操作最小子集（一共 5 种）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串的三种表示方式"><span class="nav-text">3. 串的三种表示方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-数组和多维表"><span class="nav-text">第五章 数组和多维表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多维表的地址计算"><span class="nav-text">1. 多维表的地址计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-树与二叉树"><span class="nav-text">第六章 树与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#树的性质"><span class="nav-text">1. 树的性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树基本概念和性质"><span class="nav-text">2. 二叉树基本概念和性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的存储"><span class="nav-text">3. 二叉树的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线索二叉树"><span class="nav-text">4. 线索二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的存储"><span class="nav-text">5. 树的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#森林与二叉树转换"><span class="nav-text">6. 森林与二叉树转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的遍历"><span class="nav-text">7. 树的遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-图"><span class="nav-text">第七章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图的概念"><span class="nav-text">1. 图的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的存储"><span class="nav-text">2. 图的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成树"><span class="nav-text">3. 生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dag-图aov-网拓扑排序"><span class="nav-text">4. DAG 图、AOV 网、拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aoe-网关键路径"><span class="nav-text">5. AOE 网、关键路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路径"><span class="nav-text">6. 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dijkstra"><span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floyd"><span class="nav-text">Floyd</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-查找"><span class="nav-text">第九章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念-1"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态查找结构"><span class="nav-text">2. 静态查找结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序表查找"><span class="nav-text">顺序表查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#折半查找"><span class="nav-text">折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分块查找索引顺序表"><span class="nav-text">分块查找(索引顺序表)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态查找"><span class="nav-text">3. 动态查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bst-二叉搜索树"><span class="nav-text">BST 二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avl-平衡二叉树"><span class="nav-text">AVL 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-树"><span class="nav-text">B-树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-text">4. 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希函数构造方法"><span class="nav-text">哈希函数构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理冲突"><span class="nav-text">处理冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-排序"><span class="nav-text">第十章 排序</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zuo Yiping</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 â€“ <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.0</div>





  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

</body>
</html>
