<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1. 从最优化引出的拉格朗日乘数法 1.1 一个最简单的无约束优化问题 在学习与工程之中，我们时常会遇到一些优化的问题，也就是要对某个目标函数求取极值，最简单的形式如下。 \[ \large \min_{x \in \mathbb{R^n}}{f(x)} \] 这个式子表达的含义是以 \(x\) 为自变量，求取 \(f(x)\) 的最小值。如果想要求取最大值，可以把 \(f\) 加一个">
<meta name="keywords" content="优化理论">
<meta property="og:type" content="article">
<meta property="og:title" content="拉格朗日对偶">
<meta property="og:url" content="http://yoursite.com/2019/05/15/拉格朗日对偶/index.html">
<meta property="og:site_name" content="Frostime">
<meta property="og:description" content="1. 从最优化引出的拉格朗日乘数法 1.1 一个最简单的无约束优化问题 在学习与工程之中，我们时常会遇到一些优化的问题，也就是要对某个目标函数求取极值，最简单的形式如下。 \[ \large \min_{x \in \mathbb{R^n}}{f(x)} \] 这个式子表达的含义是以 \(x\) 为自变量，求取 \(f(x)\) 的最小值。如果想要求取最大值，可以把 \(f\) 加一个">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/1-1_拉格朗日乘数法.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/2_infsup.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/2_凹凸.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/4_关系.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/5_gap.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/5_strong.png">
<meta property="og:updated_time" content="2019-05-17T05:13:08.749Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="拉格朗日对偶">
<meta name="twitter:description" content="1. 从最优化引出的拉格朗日乘数法 1.1 一个最简单的无约束优化问题 在学习与工程之中，我们时常会遇到一些优化的问题，也就是要对某个目标函数求取极值，最简单的形式如下。 \[ \large \min_{x \in \mathbb{R^n}}{f(x)} \] 这个式子表达的含义是以 \(x\) 为自变量，求取 \(f(x)\) 的最小值。如果想要求取最大值，可以把 \(f\) 加一个">
<meta name="twitter:image" content="http://yoursite.com/2019/05/15/拉格朗日对偶/1-1_拉格朗日乘数法.png">






  <link rel="canonical" href="http://yoursite.com/2019/05/15/拉格朗日对偶/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>拉格朗日对偶 | Frostime</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Frostime</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/拉格朗日对偶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zuo Yiping">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frostime">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">拉格朗日对偶

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-15 13:59:30" itemprop="dateCreated datePublished" datetime="2019-05-15T13:59:30+08:00">2019-05-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-17 13:13:08" itemprop="dateModified" datetime="2019-05-17T13:13:08+08:00">2019-05-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数学/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="从最优化引出的拉格朗日乘数法">1. 从最优化引出的拉格朗日乘数法</h1>
<h2 id="一个最简单的无约束优化问题">1.1 一个最简单的无约束优化问题</h2>
<p>在学习与工程之中，我们时常会遇到一些优化的问题，也就是要对某个目标函数求取极值，最简单的形式如下。</p>
<p><span class="math display">\[
\large \min_{x \in \mathbb{R^n}}{f(x)}
\]</span></p>
<p>这个式子表达的含义是以 <span class="math inline">\(x\)</span> 为自变量，求取 <span class="math inline">\(f(x)\)</span> 的最小值。如果想要求取最大值，可以把 <span class="math inline">\(f\)</span> 加一个符号，这样把 <span class="math inline">\(\max_{x}{f(x)}\)</span> 转换为等价的 <span class="math inline">\(\min_{x}{-f(x)}\)</span> 就行了。另外需要注意的是 <strong><span class="math inline">\(x\)</span> 并非一个标量数值，而是n维实数空间上的一个向量。</strong></p>
<p>这样的例子有很多，最常见的就比如我们在机器学习中经常碰到的最小化代价函数。对于这样的问题，我们求解的方法很简单，只要能够求出一个点 <span class="math inline">\(x^\prime\)</span>，使得 <span class="math inline">\(\nabla f(x^\prime) = 0\)</span> 即可。</p>
<p>当然我们也知道，只有当 <span class="math inline">\(f\)</span> 是凸函数的时候，这样求出来的才是全局最优点，否则不过是个局部最优点罢了。不过这就不在我们的讨论范围内了。现在我们姑且假定讨论的 <span class="math inline">\(f\)</span> 都是凸函数。</p>
<h2 id="带有等式约束的优化问题">1.2 带有等式约束的优化问题</h2>
<p>我们在上一节的基础上进一步，如果 <span class="math inline">\(f\)</span> 是有约束的呢？</p>
<p><span class="math display">\[
\large
\begin{aligned}
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad h_i(x) = 0, i \in [1, l]
\end{aligned}
\]</span></p>
<p>在这个问题中，我们对在定义域上的 <span class="math inline">\(x\)</span> 有了 <span class="math inline">\(l\)</span> 个等式约束 <span class="math inline">\(h_i\)</span>。这样一来我们就不能随意的计算导数等于0的点作为最优点了。那要怎么做呢？</p>
<p>这时就需要用到拉格朗日乘数法了，具体而言，我们首先来构建这么一个拉格朗日函数:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;L(x, \lambda) = f(x) + \sum_{i=1}^{l}\lambda_ih_i(x)\\
&amp;x \in \mathbb{R^n}, \lambda \in \mathbb{R^l}
\end{aligned}
\]</span> 这里 <span class="math inline">\(\lambda\)</span> 是新引入的参数，被称为拉格朗日乘子，在这里它是一个 <span class="math inline">\(l\)</span> 维的向量。</p>
<p>接着我们需要求解方程:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
&amp;\frac{\partial L}{\partial x} = 0\\
&amp;h_i(x) = 0
\end{aligned}
\right.
\]</span></p>
<p>求解出来的结果 <span class="math inline">\(x^\prime\)</span> 必然就是最大值或最小值对应的点，只要稍加检验就可以得出结果了。</p>
<p>那么为什么会这样呢？这里我们稍加解释，如下图所示，<span class="math inline">\(f(x, y)\)</span> 是我们的目标函数 <span class="math inline">\(f(x)\)</span>，而 <span class="math inline">\(g(x, y)\)</span> 则是我们的约束条件 <span class="math inline">\(h(x)\)</span>。</p>
<figure>
<img src="/2019/05/15/拉格朗日对偶/1-1_拉格朗日乘数法.png" alt="拉格朗日乘数法"><figcaption>拉格朗日乘数法</figcaption>
</figure>
<p>显然我们的目标就是求出在 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 的交点上的最小值。稍加思索，我们不难发现，<strong>这样的点一定是两个 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(f\)</span> 的某个等高线相切的一个点</strong>。原因很简单：假定我们的目标 <span class="math inline">\(x^*\)</span> 不是切点，那么它必然可以沿着负梯度的方向朝着更低的方向前进，那这就意味着它必然不是最小值对应的点。</p>
<p>所以我们就有结论:</p>
<blockquote>
<p>若 <span class="math inline">\(x^*\)</span> 是被等式 <span class="math inline">\(h\)</span> 约束的最优化问题 <span class="math inline">\(\min f\)</span> 的解，则 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(x^*\)</span> 处相切</p>
</blockquote>
<p>既然 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(x^*\)</span> 上相切，那就意味着二者<strong>在这一点的梯度的方向相同</strong>，即: <span class="math display">\[
\nabla f = \lambda \nabla h,\quad \lambda \not = 0
\]</span></p>
<p>稍加整理，我们就可以得出结论，只要 <span class="math inline">\(x\)</span> 满足: <span class="math display">\[
\left\{
\begin{aligned}
&amp;\frac{\mathbb{d}f}{\mathbb{d}x} + \lambda\frac{\mathbb{d}h}{\mathbb{d}x} = 0\\
&amp;h(x) = 0
\end{aligned}
\right.
\]</span> 那么 <span class="math inline">\(x\)</span> 就是我们希望的最优点。稍加整理就是上面的拉格朗日函数的形式了。</p>
<p>更详细的解释见<a href="https://www.matongxue.com/madocs/939.html" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="再加上不等式约束">1.3 再加上不等式约束</h2>
<p>然而实际生活中我们可能碰到的问题比上面的还要复杂，不仅仅是有等式约束，还可能会有不等式约束。</p>
<p>现在假定 <span class="math inline">\(f(x),\ c_i(x),\ h_i(x)\)</span> 都是定义在 <span class="math inline">\(\mathbb{R^n}\)</span> 上的连续可微函数，则考虑约束最优化问题: <span class="math display">\[
\large
\begin{aligned}
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad c_i(x) \leqslant 0, i \in [1, k]\\
&amp;\qquad h_j(x) = 0, j \in [1, l]\\
\end{aligned} \tag{1}
\]</span></p>
<p>式(1)就是我们实际会遇到的优化问题的基本形式。如何求解这个优化问题也就是这篇文章主要要探讨的。</p>
<p>关于具体如何求解，我们从<a href="#Section3">第三节</a>再开始讲其。第二节中，我们主要先把一些需要用到的数学概念理清了。</p>
<h1 id="预备的数学知识">2. 预备的数学知识</h1>
<h2 id="数学符号说明">2.1 数学符号说明</h2>
<h3 id="minmax-符号"><span class="math inline">\(\min\)</span>/<span class="math inline">\(\max\)</span> 符号</h3>
<p>在接下来你会看到一大堆这样: <span class="math display">\[
\min_{x} f(x) \tag{a}
\]</span> 这样的: <span class="math display">\[
\max_{x \in D}f(x, \lambda) \tag{b}
\]</span> 甚至这样的: <span class="math display">\[
\max_{\lambda}\min_{x}f(x, \lambda) \tag{c}
\]</span> 所以如果不把 <span class="math inline">\(\min_x\)</span> 或者 <span class="math inline">\(\max_x\)</span> 这个符号搞清楚的话，接下来可能会很难受。</p>
<p>简而言之，式子(a)的意思是对于函数 <span class="math inline">\(f(x)\)</span> ，考察 <span class="math inline">\(x\)</span> (可以理解为改变 <span class="math inline">\(x\)</span>)，来找到它的最小值。有时候在 <span class="math inline">\(\min\)</span> 的下标的位置还会带上一些限制条件，比如(b)中的 <span class="math inline">\(x \in D\)</span>，意思就是“考察在集合 D 中的 <span class="math inline">\(x\)</span>”。</p>
<p>这个符号的含义在函数只有一个自变量 <span class="math inline">\(x\)</span> 的时候倒不会出现什么混淆，但是当自变量不止一个的时候就容易弄混了。来我们来看看式子(b): <span class="math display">\[
\max_{x \in D}f(x, \lambda) \tag{b}
\]</span> 函数 <span class="math inline">\(f\)</span> 是一个关于 <span class="math inline">\(x, \lambda\)</span> 两个变量的函数。所以式子(b)的含义就是<strong>固定 <span class="math inline">\(\lambda\)</span> 不变，改变 <span class="math inline">\(x\)</span> 从而使得 <span class="math inline">\(f\)</span> 的值最小</strong>。有时候可能会看到这样的格式: <span class="math display">\[
g(\lambda) = \max_{x \in D}f(x, \lambda)
\]</span> 这个式子的意思是: - <span class="math inline">\(g(\lambda)\)</span> 是一个关于 <span class="math inline">\(\lambda\)</span> 的函数 - 当 <span class="math inline">\(\lambda = y\)</span> 时，<span class="math inline">\(g(\lambda)\)</span> 的取值为：固定 <span class="math inline">\(f(x, \lambda)\)</span> 中的 <span class="math inline">\(\lambda = y\)</span>，变动 <span class="math inline">\(x\)</span> 时 <span class="math inline">\(f\)</span> 能取到的最大值</p>
<p>比如: <span class="math display">\[
\begin{aligned}
&amp;&amp;f(x, y) &amp;= x^2 + y^2\\
&amp;&amp;g(y) &amp;= \min_{x \in D}f(x, y)\\
&amp;&amp;g(4) &amp;= \min_{x \in D}f(x, 4)\\
&amp;&amp; &amp;= \min_{x \in D}(x^2 + 16)\\
&amp;&amp; &amp;= 0 + 16 = 16
\end{aligned}
\]</span></p>
<p>在进一步，有时候 <span class="math inline">\(\min\)</span> 还有 <span class="math inline">\(\max\)</span> 会像(c)一样叠加在一起: <span class="math display">\[
v = \max_{\lambda}\min_{x}f(x, \lambda)
\]</span> 这个式子要从右往左看，首先把 <span class="math inline">\(\min_{x}f(x, \lambda)\)</span> 这一项理解成关于 <span class="math inline">\(\lambda\)</span> 的函数 <span class="math inline">\(g(\lambda)\)</span>，然后再对 <span class="math inline">\(g\)</span> 求最大值，即: <span class="math display">\[
\begin{aligned}
&amp;g(\lambda) = \min_{x}f(x, \lambda)\\
&amp;v = \max_\lambda{g(\lambda)}
\end{aligned}
\]</span></p>
<h3 id="inf-和-sup-符号"><span class="math inline">\(\inf\)</span> 和 <span class="math inline">\(\sup\)</span> 符号</h3>
<p><span class="math inline">\(\inf\)</span> 是 infimum (下确界) 的简称，而 <span class="math inline">\(\sup\)</span> 是 supremum (上确界) 的简称。它们和 min 还有 max 很相似，但是细节部分略有不同。具体来讲，一个例子足以:</p>
<p>有函数 <span class="math inline">\(\large f(x) = \frac{sin(x)}{x}\)</span>:</p>
<p><img src="/2019/05/15/拉格朗日对偶/2_infsup.png"></p>
<p>显然 <span class="math inline">\(f\)</span> 在 0 处没有定义。那么:</p>
<ul>
<li><span class="math inline">\(\max{f}\)</span> 不存在</li>
<li><span class="math inline">\(\sup{f}\)</span> 存在，且为1</li>
</ul>
<h3 id="其他符号">其他符号</h3>
<ul>
<li><span class="math inline">\(dom\ f\)</span>: 函数 <span class="math inline">\(f\)</span> 的定义域</li>
<li><span class="math inline">\(\bigcap S_i\)</span>: 对若干集合 <span class="math inline">\(S_i\)</span> 求并集</li>
</ul>
<h2 id="凸函数和凹函数">2.2 凸函数和凹函数</h2>
<p>关于这两个，我有一言请诸位静听:</p>
<p><img src="/2019/05/15/拉格朗日对偶/2_凹凸.png"></p>
<p>没错，其实是上凹下凸，这是国际惯例，我们国内的定义(也就是中学教的)是反过来的，<strong>我们在此后一律使用国际标准</strong>。</p>
<p>另外关于凸函数和凹函数有性质如下:</p>
<ol type="1">
<li>若函数 <span class="math inline">\(f: \mathbb{R^n} \to \mathbb{R}\)</span> 是凸的，则:</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x,\ y \in dom\ f,\ \forall \theta \in [0, 1]\\
&amp;f(\theta x + (1 - \theta)y) \leqslant \theta f(x) + (1 - \theta) f(y)
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li>若函数 <span class="math inline">\(f: \mathbb{R^n} \to \mathbb{R}\)</span> 是凹的，则:</li>
</ol>
<p><span class="math display">\[
\begin{aligned}
&amp;\forall x,\ y \in dom\ f,\ \forall \theta \in [0, 1]\\
&amp;f(\theta x + (1 - \theta)y) \geqslant \theta f(x) + (1 - \theta) f(y)
\end{aligned}
\]</span></p>
<h2 id="仿射函数">2.3 仿射函数</h2>
<p>假如有 <span class="math inline">\(\vec{x} \in \mathbb{R^n}\)</span>, <span class="math inline">\(\vec{b} \in \mathbb{R^m}\)</span>, 矩阵 <span class="math inline">\(A_{m\times n}\)</span>，那么:</p>
<p><span class="math display">\[
\vec x \rightarrow A\vec x + \vec b
\]</span></p>
<p>被称为 <span class="math inline">\(\mathbb{R^n} \rightarrow \mathbb{R^m}\)</span> 的仿射变换，这一过程被称为仿射函数。 <span class="math display">\[
f(x) = Ax + b,\ x\in \mathbb{R^n}
\]</span></p>
<p>比如最简单的: <span class="math display">\[
a_1x_1 + a_2x_2 + \cdots + a_nx_n + b
\]</span> 就是一个仿射函数。</p>
<p>仿射函数有一个非常重要的性质，那就是它<strong>既凹又凸</strong>，准确来讲在凹凸函数的那个不等式中，仿射函数是可以取等号的: <span class="math display">\[
f(\theta x + (1 - \theta)y) = \theta f(x) + (1 - \theta) f(y)
\]</span> 这个证明很简单，自己都可以试试。</p>
<h2 id="凸优化">2.4 凸优化</h2>
<p>我们在 1.3 节中的式 (1) 给出的式子其实是优化问题的基本形式: <span class="math display">\[
\large
\begin{aligned}
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad c_i(x) \leqslant 0, i \in [1, k]\\
&amp;\qquad h_j(x) = 0, j \in [1, l]\\
\end{aligned}
\]</span></p>
<p>而所谓的凸优化，是满足一些特定条件的优化问题，它要求:</p>
<ol type="1">
<li><span class="math inline">\(f(x)\)</span> 是凸函数</li>
<li><span class="math inline">\(c_i(x)\)</span> 是凸函数</li>
<li><span class="math inline">\(h_j(x)\)</span> 是仿射函数</li>
</ol>
<p>也就是 <span class="math display">\[
\large
\begin{aligned}
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad c_i(x) \leqslant 0, i \in [1, k]\\
&amp;\qquad a_jx = b_j, j \in [1, l]\\
\end{aligned}
\]</span></p>
<p>凸优化有一个重要的性质：<strong>任意位置的局部最优解同时也是全局最优解</strong>。</p>
<h1 id="从广义拉格朗日函数到拉格朗日对偶函数">3. 从广义拉格朗日函数到拉格朗日对偶函数</h1>
<p><span id="Section3"></span></p>
<p>OK，做了一大堆铺垫，我们终于要开始正式将拉格朗日对偶了。</p>
<p>首先来回忆一下我们的原问题 (Primal Problem): <span class="math display">\[
\large
\begin{aligned}
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad c_i(x) \leqslant 0, i \in [1, k]\\
&amp;\qquad h_j(x) = 0, j \in [1, l]\\
\end{aligned} \tag{1}
\]</span></p>
<p>首先我们做两个约定:</p>
<ul>
<li>我们<strong>不假定原函数 <span class="math inline">\(f\)</span> 的凹凸性</strong>，也就是 <span class="math inline">\(f\)</span> 可以是非凸非凹函数</li>
<li>记问题的定义域 <span class="math inline">\(D = (dom\ f)\cap(\bigcap_{i=1}^k{c_i})\cap (\bigcap_{i=1}^l{h_i})\)</span></li>
<li><span class="math inline">\(D \not = \empty\)</span></li>
<li>我们约定最终求出来的最优结果用 <span class="math inline">\(p^*\)</span> 表示</li>
</ul>
<h2 id="啥是对偶">3.1 啥是对偶？</h2>
<p>对于原问题(1)我们通常用拉格朗日对偶的方式来求解。啥是对偶？对偶说白了就是<strong>实质相同但从不同角度提出不同提法的一对问题</strong>。有时候原问题 (Primal Problem) 不太好解，但是对偶问题 (Dual Problem) 却很好解，我们就可以通过求解对偶问题来迂回地解答原问题。</p>
<p>在这里我们用的是拉格朗日对偶的方法来解决，既然我们说用对偶的方法的原因在于原问题不好解，那么这里也是如此吗？</p>
<p>当然了。</p>
<p>首先我们来看看原问题有什么难的地方:</p>
<p><span id="Section31"></span></p>
<ol type="1">
<li>约束条件太多<br>
很显然约束越多，问题就越难解决，原问题中总共有 <span class="math inline">\(k + l\)</span> 个约束，相当麻烦</li>
<li>原问题凹凸性不明确<br>
之前我们说过，“不假定原函数 <span class="math inline">\(f\)</span> 的凹凸性”，这就意味着我们无法将凸优化的方法应用在原问题中</li>
</ol>
<p>那么它的拉格朗日对偶问题有什么优点呢？</p>
<ol type="1">
<li>只有一个约束</li>
<li>拉格朗日对偶问题<strong>一定是凹的</strong></li>
</ol>
<p>这里先做一个感性的认识，细节方面接下来慢慢说。</p>
<h2 id="广义-lagrange-函数">3.3 广义 Lagrange 函数</h2>
<p>早前我们说过，对于等式约束问题可以用构建拉格朗日函数的方法来求解。这里也一样，我们可以为原问题构建一个广义拉格朗日函数 <span class="math inline">\(\mathcal{L}\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathcal{L}: \mathbb{R^n}\times \mathbb{R^k}\times \mathbb{R^l} \rightarrow R\\
&amp;\mathcal{L}(x, \lambda, \mu) = f(x) + \sum_{i = 1}^{k}{\lambda_ic_i(x)} + \sum_{j = 1}^{l}{\mu_jh_j(x)}\\
&amp;\vec x \in \mathbb{R^n},\ \vec \lambda \in \mathbb{R^k},\ \vec \mu \in \mathbb{R^l}
\end{aligned} \tag{2}
\]</span> <span class="math inline">\(\vec \lambda\)</span> 和 <span class="math inline">\(\vec \mu\)</span> 被称为拉格朗日乘子向量。</p>
<p>有了这个广义拉格朗日函数，现在我们分别可以定义另外对偶函数 <span class="math inline">\(g\)</span>。</p>
<h2 id="lagrange-对偶函数-g">3.4 Lagrange 对偶函数 <span class="math inline">\(g\)</span></h2>
<p>我们可以根据 <span class="math inline">\(\mathcal{L}\)</span> 定义一个拉格朗日对偶函数 (Lagrange Dual Function) <span class="math inline">\(g(\lambda, \mu)\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;&amp;g(\lambda, \mu) &amp;= \inf_{x\in D}{\mathcal{L}(x, \lambda, \mu)}\\
&amp;&amp;\ &amp;=\inf_{x\in D}{\big (f(x) + \sum_{i = 1}^{k}{\lambda_ic_i(x)} + \sum_{j = 1}^{l}{\mu_jh_j(x)}\big )}\\
&amp;&amp;\lambda \geqslant 0
\end{aligned} \tag{3}
\]</span></p>
<p>注意到 <span class="math inline">\(\lambda \geqslant 0\)</span> 这个要求，为什么会有这么一个要求我们下一节讲，现在先看一些别的。</p>
<p>这个对偶函数 <span class="math inline">\(g\)</span> 有一个非常重要的性质：<strong>它一定是一个凹函数</strong>，我们可以证明一下。</p>
<p>首先我们明确一个凹函数具有性质: <span class="math display">\[
f(\theta x + (1 - \theta)y) \geqslant \theta f(x) + (1 - \theta) f(y)
\]</span> 要证明 <span class="math inline">\(g\)</span> 是一个凹函数就是要证明它满足这个不等式。</p>
<ul>
<li>第一步</li>
</ul>
<p>我们首先记: <span class="math display">\[
g(\lambda, \mu) = \inf_{x\in D}\{\mathcal{L}(x_1, \lambda, \mu), \mathcal{L}(x_2, \lambda, \mu), \cdots, \mathcal{L}(x_n, \lambda, \mu)\}, x\to +\infty
\]</span></p>
<p>这个好理解，我是就是把 <span class="math inline">\(g\)</span> 看作一个逐点求下界的无穷集合。</p>
<ul>
<li>第二步</li>
</ul>
<p>简记: <span class="math display">\[
\gamma = (\lambda, \mu),\ g(\gamma) = g(\lambda, \mu)
\]</span> 这个主要是为了一会推导的时候方便写。</p>
<ul>
<li>第三步</li>
</ul>
<p>证明过程如下: <span class="math display">\[
\begin{aligned}
&amp;g(\theta\gamma_1 + (1 - \theta)\gamma_2)\\
&amp;= \inf\{\mathcal{L}(x_1, \theta\gamma_1 + (1 - \theta)\gamma_2),\ \mathcal{L}(x_2, \theta\gamma_1 + (1 - \theta)\gamma_2),\ \cdots,\ \mathcal{L}(x_n, \theta\gamma_1 + (1 - \theta)\gamma_2)\}\\
&amp;\geqslant \inf\{\theta\mathcal{L}(x_1, \gamma_1) + (1-\theta)\mathcal{L}(x_1, \gamma_2),\ \cdots,\ \theta\mathcal{L}(x_n, \gamma_1) + (1-\theta)\mathcal{L}(x_n, \gamma_2)\}\\
&amp;\geqslant\theta\inf\{\mathcal{L}(x_1, \gamma_1),\ \mathcal{L}(x_2, \gamma_1), \cdots,\ \mathcal{L}(x_n, \gamma_1)\} + (1 - \theta)\inf\{\mathcal{L}(x_1, \gamma_2),\ \mathcal{L}(x_2, \gamma_2), \cdots,\ \mathcal{L}(x_n, \gamma_2)\}\\
&amp;=\theta g(\gamma_1) + (1 - \theta)g(\gamma_2)
\end{aligned}
\]</span></p>
<p>来逐行解释一下:</p>
<ul>
<li>第一行：之前讲过了，略</li>
<li><p>第二行<br>
注意到 <span class="math inline">\(\mathcal{L}(x_i, \gamma)\)</span> 中，<span class="math inline">\(x_i\)</span> 的值<strong>已经固定了</strong>，<span class="math inline">\(\therefore f(x),\ c_i(x),\ h_i(x)\)</span> 都是常数，我们分别记为 <span class="math inline">\(r, p, q\)</span>。则: <span class="math display">\[
\mathcal{L}(x_i, \gamma) = \sum{\lambda_i p_i} + \sum{\mu_j q_j} + r
\]</span> 显然，<span class="math inline">\(\mathcal{L}\)</span> 是一个仿射函数，而我们知道仿射函数又凸又凹，所以有: <span class="math display">\[
\mathcal{L}(x_n, \theta\gamma_1 + (1 - \theta)\gamma_2) \geqslant \theta \mathcal{L}(x_n, \gamma_1) + (1 - \theta) \mathcal{L}(x_n, \gamma_2)
\]</span> 整理一下，就有了第二行。</p></li>
<li><p>第三行<br>
从第二行到第三行，运用了一个简单的数学原理: <span class="math display">\[
min\{a_i + b_i\} \geqslant min\{a\} + min\{b\}
\]</span></p></li>
</ul>
<blockquote>
<p>总结: <strong>不管原函数 <span class="math inline">\(f\)</span> 的凹凸性，它的对偶函数 <span class="math inline">\(g\)</span> 一定是凹函数</strong></p>
</blockquote>
<h2 id="对偶函数与原函数的关系">3.5 对偶函数与原函数的关系</h2>
<p>我们之所以需要这么一个对偶函数是因为 <span class="math inline">\(g\)</span> 有一个非常重要的作用，引用一句《凸优化》原文的句子:</p>
<blockquote>
<p>Give the lower bound on optimal value (<span class="math inline">\(p^*\)</span>)</p>
</blockquote>
<p>什么意思呢？其实这是 Dual Function 一个很重要的性质: <span class="math display">\[
\forall \lambda \geqslant 0 \Rightarrow g(\lambda, \mu) \leqslant p^*  \tag{4}
\]</span> 换而言之，只要 <span class="math inline">\(\lambda\)</span> 不小于0，<strong><span class="math inline">\(g\)</span> 的值用于不会超过 <span class="math inline">\(p^*\)</span></strong>！</p>
<p>要证明这个定理并不难，我们首先假设 <span class="math inline">\(\hat x \in D\)</span> 是原问题的一个可行解:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \because c_i(\hat x) \leqslant 0,\ h_i(\hat x) = 0\\
&amp; \therefore \lambda_ic_i \leqslant 0, \mu_ih_i = 0\\
&amp; \therefore \mathcal{L}(\hat x, \lambda, \mu) = f(x) + \sum_{i = 1}^{k}{\lambda_ic_i(\hat x)} + \sum_{j = 1}^{l}{\mu_jh_j(\hat x)} \leqslant f(x)\\
&amp; \text{Meanwhile}\quad g(\lambda, \mu) = \inf{\mathcal{L}},\quad p^* = \min f\\
&amp; \therefore g(\lambda, \mu) \leqslant \mathcal{L} \leqslant p^*
\end{aligned}
\]</span></p>
<p>这给了我们一个重要的启示，无论如何，<strong><span class="math inline">\(p^*\)</span> 都不会小于 <span class="math inline">\(\max{g(\lambda, \mu)}\)</span></strong>。</p>
<h1 id="从原问题到拉格朗日对偶问题">4. 从原问题到拉格朗日对偶问题</h1>
<p>在此之前，我们讲了原问题，讲了广义拉格朗日函数和拉格朗日对偶函数，又讲了这两个之间的关系。那么这有什么用呢？</p>
<p>用处当然很大啦！现在我们不妨这么一想，既然 Lagrange 对偶函数给出了最优解 <span class="math inline">\(p^*\)</span> 的下界，那么请问:</p>
<blockquote>
<p>What is the best lower bound that can be obtained from lagrange dual function?</p>
</blockquote>
<p>啥意思？我们来捋一捋:</p>
<ol type="1">
<li>首先我们明确一件事，我们的目的是找到最优解 <span class="math inline">\(p^*\)</span></li>
<li>有时候 <span class="math inline">\(p^*\)</span> 其实并不一定能解出来，这种情况下，我们希望可以<strong>给出一个尽可能地逼近 <span class="math inline">\(p^*\)</span> 的值</strong></li>
<li>既然我们已经知道了 <span class="math inline">\(g\)</span> 可以给出下界，那么那个值能够尽可能逼近呢？</li>
<li>答案是: <span class="math inline">\(\max g(\lambda, \mu)\)</span> (<span class="math inline">\(s.t\ \lambda \geqslant 0\)</span>)</li>
</ol>
<figure>
<img src="/2019/05/15/拉格朗日对偶/4_关系.png" alt="最接近 p^* 的那个它"><figcaption>最接近 <span class="math inline">\(p^*\)</span> 的那个它</figcaption>
</figure>
<p>明白了这一点，我们终于可以介绍拉格朗日对偶问题了。</p>
<p>首先再次回顾一下原问题。 <span class="math display">\[
\large
\text{Primal Problem}\\
\begin{aligned}
\\
&amp;\min_{x \in \mathbb{R^n}}{f(x)}\\
&amp;s.t \quad c_i(x) \leqslant 0, i \in [1, k]\\
&amp;\qquad h_j(x) = 0, j \in [1, l]\\
\end{aligned} \tag{1}
\]</span> 然后隆重介绍对偶问题的形式。 <span class="math display">\[
\large
\text{Lagrange Dual Problem}\\
\begin{aligned}
\\
&amp;\max_{\lambda, \mu}g(\lambda, \mu) = \max_{\lambda, \mu}\inf_{x\in D}{\mathcal{L}(x, \lambda, \mu)}\\
&amp;s.t \quad \lambda_i \geqslant 0,\ i = 1, 2,\dots, k\\
\end{aligned} \tag{5}
\]</span></p>
<p>参考上面那幅图，其实这个所谓的对偶问题在干什么已经很清楚了。我们把问题 (1) 的结果令为 <span class="math inline">\(p^*\)</span>，而问题 (5) 的结果记为 <span class="math inline">\(d^*\)</span>。</p>
<p>现在回顾一下之前说的<a href="#Section31">求解对偶问题的好处</a>，我们再来看看为什么需要拉格朗日对偶。</p>
<p>首先是问题 (1) 有哪些 annoying 的地方: 1. 原问题的约束太多了，又是等式又是不等式 2. 问题 (1) 不一定是一个凸优化问题，所以即便找到了貌似是 <span class="math inline">\(p^*\)</span> 的点，也很可能不过是个局部最优点。</p>
<p>那 Lagrange 对偶问题 (5) 就好一些吗？还真是，我们来康康:</p>
<ol type="1">
<li>约束少了，这是很明显的，少了 <span class="math inline">\(l\)</span> 个，而且剩下的 <span class="math inline">\(k\)</span> 个约束也比原来的简单一些</li>
<li>最最重要的，<strong>问题 (5) 一定是一个凸优化问题</strong>，所以很多凸优化的手段全可以用上了</li>
</ol>
<p>总结一下就是:</p>
<blockquote>
<p>我们希望求 <span class="math inline">\(p^*\)</span>，但是 <span class="math inline">\(p^*\)</span> 实在不好求，所以退而求其次去求 <span class="math inline">\(d^*\)</span>，这个就好求多了。<br>
并且由于 <span class="math inline">\(d^* \leqslant p^*\)</span>，我们在求出了 <span class="math inline">\(d^*\)</span> 后即便不能得到 <span class="math inline">\(p^*\)</span>，也可以得到 <span class="math inline">\(p^*\)</span> 的下界；而在一些非常理想的情况下，<span class="math inline">\(d^* = p^*\)</span>。</p>
</blockquote>
<p><span class="math inline">\(d^* = p^*\)</span>？如果真能这样那简直就是天堂了，显然一般情况下这两个是不同的，但是在满足某些特殊条件时，这个等式就可以成立了。具体这些条件是什么，我们在接下来的几节里再来谈谈。</p>
<h1 id="弱对偶与强对偶">5. 弱对偶与强对偶</h1>
<h2 id="弱对偶">5.1 弱对偶</h2>
<p>所谓强弱对偶，指的是 Lagrange 对偶问题的一种性质，关于弱对偶我们其实在前面已经谈到了。</p>
<p><span class="math display">\[
d^* \leqslant p^*  \tag{6}
\]</span></p>
<p>即便原文题不是凸问题，上述的不等式也成立，这就是所谓的<strong>弱对偶性</strong> (Weak Dulity)。这样的性质即便是 <span class="math inline">\(d^*\)</span> <span class="math inline">\(p^*\)</span> 无限时也成立，也就是说:</p>
<ul>
<li>如果 <span class="math inline">\(p^* = -\infty\)</span>，则 <span class="math inline">\(d^* = -\infty\)</span></li>
<li>如果 <span class="math inline">\(d^* = +\infty\)</span>，则 <span class="math inline">\(p^* = +\infty\)</span></li>
</ul>
<p>我们还把 <span class="math inline">\(p^* - d^*\)</span> 称为<strong>最优对偶间隙</strong> (Optimal Duality Gap)，这个值必然非负。</p>
<p><img src="/2019/05/15/拉格朗日对偶/5_gap.png"></p>
<h2 id="强对偶">5.2 强对偶</h2>
<p>对于式子 (6) 还有一种很特殊的情况:</p>
<p><span class="math display">\[
d^* = p^* \tag{7}
\]</span></p>
<p>这种情况，我们称之为<strong>强对偶性</strong> (Strong Duality)。</p>
<p><img src="/2019/05/15/拉格朗日对偶/5_strong.png"></p>
<p>之所以称之为“强”对偶，正是因为这种性质相对于“弱”对偶而言对我们的意义更加重大。很显然，当我们待求解的问题是强对偶的话，那就意味着我们通过对偶问题求的的解就不再仅仅是原问题解的一个下界了，而是 <span class="math inline">\(p^*\)</span> 本身。用人话来讲就是：</p>
<blockquote>
<p>如果满足强对偶，<strong>那只要我们求出了 <span class="math inline">\(d^*\)</span> ，我们就知道了 <span class="math inline">\(p^*\)</span> 的值</strong></p>
</blockquote>
<p>显然，强对偶并不是什么时候都成立的，必须要满足一定的条件才会有强对偶这种东西。</p>
<p>下一节，我们着重讲解这些条件是什么 (充分条件、必要条件)。</p>
<h1 id="关于强对偶和最优的一些条件">6. 关于强对偶和最优的一些条件</h1>
<p>首先要明确一件事情：<strong>使满足强对偶的条件有很多种</strong>，我们这里只介绍最基本的。</p>
<h2 id="convex-slater">6.1 Convex + Slater</h2>
<blockquote>
<p>如果:</p>
<ol type="1">
<li>原问题是凸优化<br>
</li>
<li>满足 Slater 条件</li>
</ol>
<p>则一定满足强对偶<br>
注: 这是强对偶的一个<strong>充分条件</strong></p>
</blockquote>
<p>下面具体解释一下含义。</p>
<p>首先是第 1 点，在 2.4 节中我们讲到过，这意味着:</p>
<ol type="1">
<li><span class="math inline">\(f(x)\)</span> 是凸函数</li>
<li><span class="math inline">\(c_i(x)\)</span> 是凸函数</li>
<li><span class="math inline">\(h_j(x)\)</span> 是仿射函数</li>
</ol>
<p>再来看看第 2 点，所谓的 Slater 条件。严格的 Slater 条件表述如下: <span class="math display">\[
\begin{aligned}
&amp;\exists x \in D\\
&amp;c_i(x) &lt; 0, i \in [1,k]\\
&amp;Ax = b
\end{aligned} \tag{8}
\]</span> 其中 <span class="math inline">\(Ax = b\)</span> 是把 <span class="math inline">\(a_jx=b_j\)</span> 合起来写的写法，我们的主要关注点在 <span class="math inline">\(c_i\)</span> 上。我们把满足该条件的点称为是<strong>严格可行</strong>的，因为不等式约束要求严格成立。</p>
<p>之所以称上述的 Slater 条件是严格的，是因为 Slater 还有一个弱化的版本。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{若}c_i(x)\text{是仿射函数},\ i = [1, p] \And p \leqslant k\\
&amp;\text{则弱化的 Slater 条件为:}\\
&amp;\exists x \in D\\
&amp;c_i(x) \leqslant 0, i \in [1,p]\\
&amp;c_i(x) &lt; 0, i \in [p+1, k]\\
&amp;Ax = b
\end{aligned} \tag{9}
\]</span></p>
<p>任意满足: 1. 凸优化 2. 强或弱 Slater 条件</p>
<p>的优化问题同样满足强对偶性 (充分条件)。</p>
<h2 id="kkt-条件">6.2 KKT 条件</h2>
<p>有必要明确一些很重要的点。</p>
<p>首先是 KKT 条件实际上应该分为两种情况讨论:</p>
<ul>
<li>Case 1: 原问题为非凸问题情况下的 KKT</li>
<li>Case 2: 原问题为凸问题情况下的 KKT</li>
</ul>
<p>为什么要分两点来讨论？因为在两种情况下，KKT 条件作为一个“条件”的充分性和必要性是不同的，自然用法也不同。</p>
<p>再有一个问题是，无论哪种情况，KKT 都是着眼于“最优解”这个议题进行讨论的。</p>
<p>下面分两种情况讨论。</p>
<h3 id="非凸问题下的-kkt">6.2.1 非凸问题下的 KKT</h3>
<blockquote>
<p>当原问题并非凸优化(或者不清楚、不关心是不是凸优化)时，KKT 条件是一种用来<strong>描述强对偶情况下最优解性质</strong>的条件<br>
换而言之，若强对偶性质成立，那么满足最优解的<strong>点</strong>一定满足 KKT 条件；KKT 条件是强对偶一个<strong>必要条件</strong>，但无法作为充分条件来使用</p>
</blockquote>
<p>我们首先给出 KKT 条件的具体数学描述，然后逐行解释。</p>
<p>假设: 1. 原问题中的函数均可微 2. 强对偶成立 3. <span class="math inline">\(x^*\)</span> 和 <span class="math inline">\((\lambda^*, \mu^*)\)</span> 分别为原问题和对偶问题的某对最优解</p>
<p>则: <span class="math display">\[
\begin{aligned}
&amp;c_i(x^*) \leqslant 0 &amp;i = 1, \dots, k\\
&amp;h_i(x^*) = 0 &amp;i = 1, \dots, l\\
&amp;\lambda_i^* \geqslant 0 &amp;i = 1, \dots, k\\
&amp;\lambda_i^*c_i(x^*) = 0 &amp;i = 1, \dots, k\\
&amp;\nabla f(x^*) + \sum_{i=1}^{k}\lambda_i^*\nabla c_i(x^*) + \sum_{i=1}^{l}\mu_i^*\nabla h_i(x^*) = 0
\end{aligned}
\]</span></p>
<p>这就是 KKT 条件了，第一行和第二行是原问题的约束，必须遵守；第三行则是弱对偶的必要条件。最后一行，我们知道，既然 <span class="math inline">\(x^*\)</span> 是最优点，那么理所当然的，原问题 <span class="math inline">\(\mathcal{L}\)</span> 关于 <span class="math inline">\(x^*\)</span> 的导数必须等于 0。</p>
<p>现在难点主要在第四行，其实第四行的不等式是一个被称为“互补松弛条件”的东西。我们做一个简单的证明。</p>
<p>首先我们知道 <span class="math display">\[
\begin{aligned}
&amp;&amp;f(x^*) &amp;= g(\lambda^*, \mu^*)\\
&amp;&amp; &amp;= \inf_{x}{\mathcal{L}(x^*, \lambda^*, \mu^*)}\\
\end{aligned}
\]</span> 所以有: <span class="math display">\[
\begin{aligned}
&amp;&amp;f(x^*) &amp;\leqslant \mathcal{L}(x^*, \lambda^*, \mu^*)\\
&amp;&amp; &amp;= f(x^*) + \sum_{i=1}^{k}\lambda_i^*c_i(x^*) + \sum_{i=1}^{l}\mu_i^*h_i(x^*)
\end{aligned}
\]</span> 同时我们知道，<span class="math inline">\(\lambda \geqslant 0\)</span> 且 <span class="math inline">\(c_i(x) \leqslant 0\)</span>，而 <span class="math inline">\(h_i = 0\)</span>，所以有: <span class="math display">\[
f(x^*) + \sum_{i=1}^{k}\lambda_i^*c_i(x^*) + \sum_{i=1}^{l}\mu_i^*h_i(x^*) \leqslant f(x^*)
\]</span> 联立上面几个式子，有: <span class="math display">\[
\begin{aligned}
&amp;&amp;f(x^*) &amp;= g(\lambda^*, \mu^*)\\
&amp;&amp; &amp;= \inf_{x}{f(x^*) + \sum_{i=1}^{k}\lambda_i^*c_i(x^*) + \sum_{i=1}^{l}\mu_i^*h_i(x^*)}\\
&amp;&amp; &amp;= f(x^*) + \sum_{i=1}^{k}\lambda_i^*c_i(x^*) + \sum_{i=1}^{l}\mu_i^*h_i(x^*)\\
&amp;&amp; &amp;= f(x^*)
\end{aligned}
\]</span> 注意到第二行和第三行想等，而 <span class="math inline">\(\lambda_ic_i \leqslant 0\)</span>，所以为了让等式成立，必然有: <span class="math display">\[
\lambda_ic_i(x) = 0
\]</span> 这被称为互补松弛条件。</p>
<p>把这几个条件一股脑叠加在一起，就构成了 KKT 条件。对于目标函数和约束函数可微的优化问题，如果强对偶成立，则任意一对原问题的最优解和对偶问题的最优解满足 KKT 条件。</p>
<h3 id="凸问题下的-kkt">6.2.2 凸问题下的 KKT</h3>
<blockquote>
<p>当原问题为凸优化时，KKT 条件在非凸的基础上有多了找到最优点的功能<br>
在这种情况下，那么满足 KKT 条件的点一定是原问题和对偶问题的最优解；KKT 条件成了强对偶和最优解的充要条件</p>
</blockquote>
<p>也就是说: 1. 若原问题是Convex的 2. <span class="math inline">\(\exists \hat x, \hat \lambda, \hat \mu\)</span> 满足: <span class="math display">\[
\begin{aligned}
&amp;c_i(\hat x) \leqslant 0 &amp;i = 1, \dots, k\\
&amp;h_i(\hat x) = 0 &amp;i = 1, \dots, l\\
&amp;\hat \lambda_i \geqslant 0 &amp;i = 1, \dots, k\\
&amp;\hat \lambda_i c_i(\hat x) = 0 &amp;i = 1, \dots, k\\
&amp;\nabla f(\hat x) + \sum_{i=1}^{k}\hat \lambda_i \nabla c_i(\hat x) + \sum_{i=1}^{l}\hat\mu_i \nabla h_i(\hat x) = 0
\end{aligned}
\]</span></p>
<p>那么 <span class="math inline">\(\hat x\)</span> 和 <span class="math inline">\((\hat \lambda, \hat \mu)\)</span> 分别是原问题和对偶问题的最优解，且最优对偶间隙为 0，强对偶性满足。</p>
<h2 id="几种条件之间的关系的总结">6.3 几种条件之间的关系的总结</h2>
<ol type="1">
<li><p>对于任意问题<br>
强对偶 + 最优解 <span class="math inline">\(\Rightarrow\)</span> KKT条件</p></li>
<li><p>对于 Convex + 可微 的问题<br>
KKT 条件 <span class="math inline">\(\Rightarrow\)</span> 强对偶 + 最优解</p></li>
<li><p>Convex + Slater <span class="math inline">\(\Rightarrow\)</span> 强对偶</p></li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/优化理论/" rel="tag"># 优化理论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/13/第一章-线性方程组/" rel="next" title="第一章 线性方程组">
                <i class="fa fa-chevron-left"></i> 第一章 线性方程组
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/19/选择、冒泡与插入排序/" rel="prev" title="选择、冒泡与插入排序">
                选择、冒泡与插入排序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zuo Yiping</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从最优化引出的拉格朗日乘数法"><span class="nav-text">1. 从最优化引出的拉格朗日乘数法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个最简单的无约束优化问题"><span class="nav-text">1.1 一个最简单的无约束优化问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带有等式约束的优化问题"><span class="nav-text">1.2 带有等式约束的优化问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再加上不等式约束"><span class="nav-text">1.3 再加上不等式约束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#预备的数学知识"><span class="nav-text">2. 预备的数学知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数学符号说明"><span class="nav-text">2.1 数学符号说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#minmax-符号"><span class="nav-text">\(\min\)/\(\max\) 符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inf-和-sup-符号"><span class="nav-text">\(\inf\) 和 \(\sup\) 符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他符号"><span class="nav-text">其他符号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凸函数和凹函数"><span class="nav-text">2.2 凸函数和凹函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#仿射函数"><span class="nav-text">2.3 仿射函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凸优化"><span class="nav-text">2.4 凸优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从广义拉格朗日函数到拉格朗日对偶函数"><span class="nav-text">3. 从广义拉格朗日函数到拉格朗日对偶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#啥是对偶"><span class="nav-text">3.1 啥是对偶？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广义-lagrange-函数"><span class="nav-text">3.3 广义 Lagrange 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lagrange-对偶函数-g"><span class="nav-text">3.4 Lagrange 对偶函数 \(g\)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对偶函数与原函数的关系"><span class="nav-text">3.5 对偶函数与原函数的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从原问题到拉格朗日对偶问题"><span class="nav-text">4. 从原问题到拉格朗日对偶问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#弱对偶与强对偶"><span class="nav-text">5. 弱对偶与强对偶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#弱对偶"><span class="nav-text">5.1 弱对偶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强对偶"><span class="nav-text">5.2 强对偶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于强对偶和最优的一些条件"><span class="nav-text">6. 关于强对偶和最优的一些条件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#convex-slater"><span class="nav-text">6.1 Convex + Slater</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kkt-条件"><span class="nav-text">6.2 KKT 条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非凸问题下的-kkt"><span class="nav-text">6.2.1 非凸问题下的 KKT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凸问题下的-kkt"><span class="nav-text">6.2.2 凸问题下的 KKT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几种条件之间的关系的总结"><span class="nav-text">6.3 几种条件之间的关系的总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zuo Yiping</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 â€“ <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.0</div>





  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

</body>
</html>
